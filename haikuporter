#!/bin/env python
# -*- coding: utf8 -*-
# copyright 2007-2009 Brecht Machiels
# copyright 2009 HaikuBot (aka RISC)
# copyright 2009 Scott McCreary
# copyright 2009 Alexander Deynichenko

info = {}
info['version'] = "0.43"

# -- Modules ------------------------------------------------------------------

import sys
import os
import re
import urllib
import urllib2
import time
import locale
import tarfile
import zipfile
import types
import hashlib
import shutil
from optparse import OptionParser

# -- HaikuPorts options -------------------------------------------------------

# location of haikuports.conf
haikuPortsConf = '/boot/common/etc/haikuports.conf'

# create new type 'ShellType' for identifying lists of shell commands
class shell(list):
	pass
ShellType = shell

# create new type 'StatusType' for identifying the port's status on a platform
#  the possible states are defined in the 'Config' class (reStatusType)
class status(str):
	pass
StatusType = status

# allowed types of the /etc/haikuports.conf values
confTypes = {}
confTypes['PACKAGES_PATH'] = [types.StringType]
confTypes['PATCH_OPTIONS'] = [types.StringType]

# allowed types of the BepFile values
bepTypes = {}
bepTypes['DESCRIPTION']	 = [types.StringType, types.ListType]
bepTypes['HOMEPAGE']	 = [types.StringType]
bepTypes['SRC_URI']		 = [types.StringType, types.ListType]
bepTypes['CHECKSUM_MD5'] = [types.StringType]
bepTypes['REVISION']	 = [types.IntType]
bepTypes['STATUS_HAIKU'] = [StatusType]
bepTypes['DEPEND']		 = [types.StringType, types.ListType, types.NoneType]
bepTypes['BUILD']		 = [ShellType]
bepTypes['INSTALL']		 = [ShellType]

							# is field	 #	default
bepDefaults = {}			# required?	 #	value
bepDefaults['DESCRIPTION']	= [True,		None		]
bepDefaults['HOMEPAGE']		= [True,		None		]
bepDefaults['SRC_URI']		= [True,		None		]
bepDefaults['CHECKSUM_MD5']	= [False,		None		]
bepDefaults['REVISION']		= [True,		None		]
bepDefaults['WORKING']		= [False,		True		]
bepDefaults['STATUS_HAIKU']	= [False,		'untested'	]
bepDefaults['DEPEND']		= [False,		None		]
bepDefaults['BUILD']		= [False,		shell()		]
bepDefaults['INSTALL']		= [False,		shell()		]

# names of directories
paths = {}
paths['work']		= "work"
paths['patches']	= "patches"
paths['download']	= "download"
paths['distro']		= "distro"

# -- downloadProgressIndicator properties ------------------------------------

totalSteps = 35
singleStep = 100.0/totalSteps

# -- capture output of shell command -----------------------------------------
#  from http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52296

def getCommandOutput(command):
	child = os.popen(command)
	data = child.read()
	err = child.close()
	if err:
		raise RuntimeError, '%s failed w/ exit code %d' % (command, err)
	return data

# -- Set up locale for thousands seperators ----------------------------------
def _temp(lc=locale.localeconv()):
	lc.update({'thousands_sep':',','grouping':[3,3,0]})
	return lc

locale.localeconv=_temp

# -- Main Program ------------------------------------------------------------

class HaikuPorter:
	def __init__(self, options, args):
		# read global settings
		mainConfig = Config(haikuPortsConf)
		self.confKeys = mainConfig.getKeys()
		self.options = options

		for key in self.confKeys:
			try:
				if type(self.confKeys[key]) not in confTypes[key]:
					sys.exit("Error: Invalid value type for " + key + ". Expecting " + str(confTypes[key]))
			except KeyError, e:
				print "Warning: Unknown key label '" + key + "' in " + haikuPortsConf + ". Ignoring."

		self.packagesPath = self.confKeys['PACKAGES_PATH']
		if self.packagesPath[-1] == '/':
			# strip trailing '/'
			self.packagesPath = self.packagesPath[:-1]

		# if requested, list all ports in the HaikuPorts tree
		if options.list:
			self.listPorts()
			sys.exit()

		# if requested, search for a port
		if options.search:
			if len(args) == 0:
				print "You need to specifiy a search string."
				print "Invoke '" + sys.argv[0] + " -h' for usage information."
				sys.exit(1)

			self.searchPorts(args[0])
			sys.exit()

		# if requested, get ports tree
		if options.get:
			self.getTree()
			sys.exit()

		# if there is no argument given, exit
		if len(args) == 0:
			print "You need to specifiy at least a port name."
			print "Invoke '" + sys.argv[0] + " -h' for usage information."
			sys.exit(1)
		else:
			port = args[0]

		# split the argument into a port name and a version
		reWithVersion = re.compile('^(?P<name>[a-z0-9\-_]*)-(?P<version>([\d]+[a-z\\.])*[\d]*)?$')
		reWithoutVersion = re.compile('^(?P<name>[a-z0-9\-_]*)$')
		if reWithVersion.match(port):		# with version
			m = reWithVersion.match(port)
			self.portName = m.group("name")
			self.portVersion = m.group("version")
		elif reWithoutVersion.match(port):	# without version
			m = reWithoutVersion.match(port)
			self.portName = m.group("name")
			self.portVersion = None
		else:								# invalid argument
			sys.exit("Error: Invalid port name " + port)						

		# find the port in the HaikuPorts tree
		self.portCategory = self.getCategory(self.portName)
		if self.portCategory == None:
			sys.exit("Error: Port " + self.portName + " not found.")

		# create full paths for the directories
		self.portDir	= self.packagesPath + '/' + self.portCategory + '/' + self.portName
		self.downloadDir= self.portDir + '/' + paths['download']
		self.workDir	= self.portDir + '/' + paths['work']
		self.patchesDir	= self.portDir + '/' + paths['patches']
		self.distroDir	= self.portDir + '/' + paths['distro']

		# if the port version was not specified, list available versions
		if self.portVersion == None:
			versions = []
			reBepFile = re.compile('^(?P<name>[a-z0-9\-_]*)-(?P<version>([\d]+[a-z\\.])*[\d]*)?\.bep$')
			os.chdir(self.portDir)
			dirList = os.listdir(".")
			for item in dirList:
				m = reBepFile.match(item)
				if m:
					versions.append([m.group("version"), item])
			if len(versions) > 1:
				print "Following versions of %s are available:" % (self.portName)
				for version in versions:
					print "  " + version[0]
				sys.exit("Run haikuporter again, specifiying a port version")
			elif len(versions) == 1:
				self.portVersion = versions[0][0]
			else:
				sys.exit("Error: .bep files for " + self.portName +" not found.")

		# show port description, if requested
		if options.about:
			self.about()
			sys.exit()

		# read data from the bep file
		self.parseBepFile()

		# warn when the port is not stable on this platform
		self.platform = self.detectOS()
		if self.platform == None:
			sys.exit("Error: Unknown OS platform!")
		else:
			if self.bepKeys['STATUS_' + self.platform] != "stable":
				print "Warning: This port is " + self.bepKeys['STATUS_' + self.platform] + " on this platform.",
				answer = raw_input("Continue (y/n + enter)? ")
				if answer == '':
					sys.exit(1)
				if answer[0].lower() == 'y':
					print "ok"
				else:
					sys.exit(1)

		# clean the work dir and don't build when making a source archive
		if options.archive:
			options.build = False
			options.clean = True
			options.patch = True

		# clean the work directory, if requested
		if options.clean:
			self.clean()

		# don't build when not patching
		if not options.patch:
			options.build = False

		self.checkDeps()	# check dependencies
		self.fetch()		# fetch sources
		self.checksum()		# calculate checksum
		self.unpack()		# unpack source archive
		if options.patch:
			self.patch()	# apply patches
		if options.build:
			self.build()	# build
		if options.install:
			self.install()	# install
		if options.distro:
			self.distro()	# distro
		if options.archive:
			self.archive()	# create patched source archive

	def about(self):
		"""Show port description"""
		os.chdir(self.portDir)

		bepFilename = self.portName + '-' + self.portVersion + ".bep"

		reOptionValue	= re.compile('^(?P<key>[A-Z0-9_]*)\s*=\s*"(?P<value>.*)(?<!\\\\)"\s*$')
		reComment		= re.compile('^\s*#.*$')
		reEmptyLine		= re.compile('^\s*$')

		if not os.path.exists(bepFilename):
			sys.exit("Error: " + self.portName + " version " + self.portVersion + " not found.")

		fp = open(bepFilename)
		lineCount = 0

		line = fp.readline()
		lineCount += 1

		print '*'*80

		while line != "":
			# empty line or comment
			if reEmptyLine.match(line) or reComment.match(line):
				pass
			# value option (single line) (check BEFORE list option)
			elif reOptionValue.match(line):
				m = reOptionValue.match(line)
				key = m.group("key")
				value = m.group("value")
				
				if 'DESCRIPTION' in key:
					print key.capitalize()+":",value
				elif 'HOMEPAGE' in key:
					print key.capitalize()+":",value

			line = fp.readline()
			lineCount += 1

		print '*'*80

		fp.close()

	def setFlag(self, name):
		f = open('%s/haikuports.%s' %(self.workDir, name), 'w')
		f.close()

	def checkFlag(self, name):
		if os.path.exists('%s/haikuports.%s' %(self.workDir, name)):
			return True
		else:
			return False

	def getTree(self):
		"""Get/Update the port tree via svn"""
		print "Refreshing the port tree: " + self.packagesPath
		if os.path.exists(self.packagesPath + "/.svn"):
			os.system('svn update "' + self.packagesPath + '"')
		else:
			os.system('svn checkout http://ports.haiku-files.org/svn/haikuports/trunk "' + self.packagesPath + '"')

	def parseBepFile(self):
		"""Parse the BepFile of the specified port"""
		os.chdir(self.portDir)
		bepFilename = self.portName + "-" + self.portVersion + ".bep"
		if not os.path.exists(bepFilename):
			sys.exit("Error: " + self.portName + " version " + self.portVersion + " not found.")
		bepConfig = Config(bepFilename)
		self.bepKeys = bepConfig.getKeys()

		# check whether all required fields are present
		for key in bepDefaults:
			if key not in self.bepKeys and bepDefaults[key][0]:
				sys.exit("Error: Required field '" + key + "' not present in " + bepFilename)

		# check validity of BepFile values
		for key in self.bepKeys:
			try:
				if type(self.bepKeys[key]) not in bepTypes[key]:
					sys.exit("Error: Invalid value type for " + key + ". Expecting " + str(bepTypes[key]))
			except KeyError, e:
				print "Warning: Unknown key label '" + key + "'. Ignoring."

		# set default values when not provided
		for key in bepDefaults:
			if key not in self.bepKeys:
				self.bepKeys[key] = bepDefaults[key][1]

		# convert each None/string value into a list (with respectively 0 or 1 element)
		#	(simplifies implementation ahead)
		for key in bepTypes:
			if types.ListType in bepTypes[key]:
				if self.bepKeys[key] == None:
					self.bepKeys[key] = []
				elif type(self.bepKeys[key]) == types.StringType:
					self.bepKeys[key] = [self.bepKeys[key]]

		#for key in self.bepKeys:
		#	print key + " = " + str(self.bepKeys[key])

	def detectOS(self):
		"""Detect the platform we're running on"""
		name = getCommandOutput('uname -s')[0:-1]
		if name == "Haiku":
			return name.upper()
		# Support for R5, R5bone, dano, and Zeta has been dropped.
		else:
			return None

	def listPorts(self):
		"""List all of the ports in the HaikuPorts tree"""
		hierarchy = []
		os.chdir(self.packagesPath)
		dirList = os.listdir(self.packagesPath)
		for category in dirList:
			if os.path.isdir(category) and (category[0] != '.'):
				subdirList = os.listdir(category)
				# remove items starting with '.'
				subdirList.sort()
				for portName in subdirList:
					if portName[0][0] != '.':
						print category + "/" + portName

	def searchPorts(self, regExp):
		"""Search for a port in the HaikuPorts tree"""
		reSearch = re.compile(regExp)
		hierarchy = []
		os.chdir(self.packagesPath)
		dirList = os.listdir(self.packagesPath)
		for category in dirList:
			if os.path.isdir(category) and (category[0] != '.'):
				subdirList = os.listdir(category)
				# remove items starting with '.'
				subdirList.sort()
				for portName in subdirList:
					if portName[0][0] != '.' and reSearch.search(portName):
						print category + "/" + portName

	def getCategory(self, portName):
		"""Find location of the specified port in the HaikuPorts tree"""
		hierarchy = []
		os.chdir(self.packagesPath)
		dirList = os.listdir(self.packagesPath)
		for item in dirList:
			if os.path.isdir(item) and (item[0] != '.'):
				subdirList = os.listdir(item)
				# remove items starting with '.'
				subdirList.sort()
				while subdirList[0][0] == '.':
					del subdirList[0]
				# locate port
				try:
					if subdirList.index(portName) >= 0:
						# port was found in the category specified by 'item'
						return item
				except ValueError:
					pass
				hierarchy.append([item, subdirList])
		return None

	def clean(self):
		"""Clean the working directory"""
		os.chdir(self.portDir)
		if os.path.exists(paths['work']):
			print "Cleaning work directory..."
			shutil.rmtree(paths['work'])

	def checkDeps(self):
		"""Print the list of ports this one depends on"""
		if self.bepKeys['DEPEND'] == []:
			print "No dependencies"
			return
		print "This port depends on the following ports:"
		for item in self.bepKeys['DEPEND']:
			print "  " + item
		print "Please verify that you have these installed.",
		answer = raw_input("Continue (y/n + enter)? ")
		if answer == '':
			sys.exit(1)
		if answer[0].lower() == 'y':
			print "ok"
		else:
			sys.exit(1)

	def fetch(self):
		"""Fetch the source archive"""
		# create download dir
		if not os.path.exists(self.downloadDir):
			os.mkdir(self.downloadDir)
		# fetch source archive
		self.lastBytes = 0
		self.progressSpeed = 0
		self.timeLeft = None
		self.lastTime = time.time()
		os.chdir(self.downloadDir)
		for src_uri in self.bepKeys['SRC_URI']:
			fp = self.downloadDir+'/'+src_uri[src_uri.rindex('/') + 1:]
			if os.path.isfile(fp):
				print 'Seems file already exists, checkout: ' + fp + '.\nSkip fetching file...'
				self.src_local = src_uri[src_uri.rindex('/') + 1:]
				return
			else:
				print "Fetching " + src_uri
				try:
					file_uri = urllib2.urlopen(src_uri)
					headers = file_uri.info()
					remote_size = long(headers.getheader("Content-Length"))
					src_uri = file_uri.geturl()
					self.src_local = src_uri[src_uri.rindex('/') + 1:]
					if os.path.exists(self.src_local):
						local_size = os.stat(self.src_local).st_size
					else:
						local_size = 0
					# check if file was already downloaded
					if local_size == remote_size:
						print '  file was already downloaded... continuing'
					else:
						os.system('wget ' + src_uri)
						# urllib.urlretrieve(src_uri, self.src_local, self.downloadProgressIndicator)
						print ''
					# succesfully downloaded source archive
					return
				except:
					raise
					print "  error... trying next location"
					continue
		# failed to fetch source
		sys.exit("Error: Failed to fetch source package from all locations.")

	def downloadProgressIndicator(self, *a):
		"""Show a progress bar, download speed and ETA"""
		current = float(a[0])
		block = float(a[1])
		total = float(a[2])
		currentBytes = int(current * block)
		if currentBytes > total:
			currentBytes = total
		percentComplete = 100 * currentBytes / (total)
		currentStep = int(percentComplete / singleStep)
		progressBar = '['
		for step in range(totalSteps):
			if step < currentStep:
				progressBar = progressBar + '='
			elif step == currentStep:
				progressBar = progressBar + '>'
			else:
				progressBar = progressBar + ' '
		progressBar = progressBar + ']'
		currentTime = time.time()
		deltaTime = currentTime - self.lastTime
		if deltaTime > 0.5:
			deltaBytes = currentBytes - self.lastBytes
			self.progressSpeed = round(deltaBytes / deltaTime / 1000 , 2)
			self.lastTime = currentTime
			self.lastBytes = currentBytes
			bytesLeft = total - currentBytes
			if self.progressSpeed != 0:
				secondsLeft = bytesLeft / self.progressSpeed / 1000
				if secondsLeft > 3600:
					self.timeLeft = time.strftime('%H:%M:%S', time.gmtime(secondsLeft))
				else:
					self.timeLeft = time.strftime('%M:%S', time.gmtime(secondsLeft))
		
		progressInfo = str(int(percentComplete)).rjust(3)  + '% ' \
						+ progressBar \
						+ ' ' + locale.format('%d', currentBytes, grouping=True).ljust(8) \
						+ ' ' + str(self.progressSpeed).rjust(8) + 'K/s'
		if self.timeLeft != None:
			progressInfo = progressInfo \
						+ '    ' + 'ETA ' + str(self.timeLeft)
		sys.stdout.write('\r' + progressInfo)
		sys.stdout.flush()

	def checksum(self): 
		if self.bepKeys['CHECKSUM_MD5']:
			sys.stdout.write('Calculating checksum -')
			sys.stdout.flush()
			h = hashlib.md5()
			f = open(self.src_local, 'rb')
			while True:
				d = f.read(16384)
				if not d:
					break
				h.update(d)
			f.close()
			if h.hexdigest() == self.bepKeys['CHECKSUM_MD5']:
				sys.stdout.write(' OK\n')
			else:
				sys.stdout.write(' FAILED\n')
				sys.exit(1)
			sys.stdout.flush()
		else:
			print "Warning: CHECKSUM_MD5 key not found in bep file."

	def unpack(self):
		"""Unpack the source archive (into the work directory)"""
		# create work dir
		if not os.path.exists(self.workDir):
			os.mkdir(self.workDir)

		# Check to see if the source archive was already unpacked.
		if self.checkFlag('unpack') and not self.options.force:
			return

		# unpack source archive
		os.chdir(self.workDir)
		print "Unpacking " + self.src_local
		archiveFullPath = self.downloadDir + "/" + self.src_local
		if tarfile.is_tarfile(archiveFullPath): 
			tf = tarfile.open(self.downloadDir + "/" + self.src_local, 'r')
			tf.extractall()
			tf.close()
		elif zipfile.is_zipfile(archiveFullPath):
			zf = zipfile.ZipFile(self.downloadDir + "/" + self.src_local, 'r')
			zf.extractall()
			zf.close()
		else:
			sys.exit("Error: Unrecognized archive type.")

		self.setFlag('unpack')	

	def patch(self):
		"""Apply the Haiku patches to the source directory"""

		# Check to see if the patch was already applied to the source.
		if self.checkFlag('patch') and not self.options.force:
			return

		os.chdir(self.workDir)

		patchFilePath = self.patchesDir + '/' + self.portName + '-' + self.portVersion + '.patch'
		if os.path.exists(patchFilePath):
			patchOptions = ""
			if 'PATCH_OPTIONS' in self.confKeys:
				patchOptions += self.confKeys['PATCH_OPTIONS']
			os.system('patch -p0 ' + patchOptions + ' -i ' + patchFilePath)
			# TODO: check return code
		else:
			print "No patching required"
		self.setFlag('patch')

	def build(self):
		"""Build the sources"""

		# Make sure the bep file for the package has a BUILD section.
		if (not 'BUILD' in self.bepKeys) or (not self.bepKeys['BUILD']):
			sys.exit('Error: Invalid bep file with no BUILD section.')

		# Check to see if a previous build was already done.
		if self.checkFlag('build') and not self.options.force:
			return

		os.chdir(self.workDir)

		buildCommands = ''
		for command in self.bepKeys['BUILD']:
			if buildCommands != '':
				buildCommands = buildCommands + " && "
			buildCommands = buildCommands + command
		os.system(buildCommands)
		self.setFlag('build')

	def install(self):
		"""Install the binaries onto the system"""

		# Make sure the bep file for the package has an INSTALL section.
		if (not 'INSTALL' in self.bepKeys) or (not self.bepKeys['INSTALL']):
			sys.exit('Error: bep file has no INSTALL section.')

		print "Installing ..."
		os.chdir(self.workDir)
		installCommands = ''
		for command in self.bepKeys['INSTALL']:
			if installCommands != '':
				installCommands = installCommands + " && "
			installCommands = installCommands + command
		os.system(installCommands)

	def distro(self):
		"""Create a package suitable for distribution"""

		print "Creating distribution package ..."

		# Make sure the bep file for the package has an INSTALL section.
		if (not 'INSTALL' in self.bepKeys) or (not self.bepKeys['INSTALL']):
			sys.exit('Error: bep file has no INSTALL section.')

		# if the distro dir still exists from a previous run then remove it
		shutil.rmtree(self.distroDir, True)

		# create distro dir
		if not os.path.exists(self.distroDir):
			os.mkdir(self.distroDir)

		os.chdir(self.workDir)
		installCommands = ''
		for command in self.bepKeys['INSTALL']:
			if 'make install' in command:
				command = 'make install DESTDIR=' + self.distroDir
			if installCommands != '':
				installCommands = installCommands + " && "
			installCommands = installCommands + command

		os.system(installCommands)

		# get OptionalPackageDescription
		os.chdir(self.portDir)

		opd = False
		for f in os.listdir(self.portDir):
			if 'OptionalPackageDescription' in f:
				shutil.copyfile(self.portDir + '/' + f, self.distroDir + '/.OptionalPackageDescription')
				opd = True

			if 'licenses' in f:
				shutil.copytree(self.portDir + '/' + f, self.distroDir + '/common/data/licenses')

		# go to distro dir for making zip package
		os.chdir(self.distroDir)

		package = self.portName + '-' + self.portVersion

		gcc = getCommandOutput('setgcc')
		gcc = gcc.split(': ')[1].split('/')
		arch = '-' + gcc[0]
		gcc = '-' + gcc[1][:-1]

		date = time.localtime()
		date = '-' + str(date[0]) + '-' + str(date[1]) + '-' + str(date[2])

		packageFiles = ""

		if os.path.exists('./boot/apps'):
			shutil.move('./boot/apps', './apps')
			packageFiles = './apps'

		if os.path.exists('./boot/common'):
			shutil.move('./boot/common', './common')
			packageFiles += ' ./common'

		if opd:
			packageFiles += ' .OptionalPackageDescription'

		zipFile = self.portDir + '/' + package + arch + gcc + date + '.zip'

		# Zip the package and save it in the root of the port dir
		os.system('zip -9ry ' + zipFile + ' ' + packageFiles + ' -x *.svn*')

		# Clean up after ourselves
		shutil.rmtree(self.distroDir)

		print 'Package saved to: ' + zipFile

	def archive(self):
		"""Create a patched source archive"""

		print "Creating patched source archive ..."

		# Set the path and filename for the archive.
		archiveFile = self.portDir + '/' + self.portName + '-' + self.portVersion + '_haiku.tar.xz'

		sourceFiles = ""

		# Build the list of dirs to archive.
		# Since we don't know the name we have to iterate over the dir.
		for f in os.listdir(self.workDir):
			if os.path.isdir(f):
				sourceFiles += ' ' + f

		# Make sure we found something to archive
		if not sourceFiles:
			sys.exit("Error: No source directories found in work dir.")

		# Change to the work dir where the patched sources are.
		os.chdir(self.workDir)

		# Archive the package and save it in the root of the port dir.
		os.system('tar cJvf ' + archiveFile + ' ' + sourceFiles)

		# Clean up after ourselves
		shutil.rmtree(self.workDir)

		print 'Archive saved to: ' + archiveFile

# -- /etc/haikuports.conf and *.bep parser -----------------------------------

class Config:
	def __init__(self, filename):
		# regular expressions for parsing the config file
		reOptionValue	= re.compile('^(?P<key>[A-Z0-9_]*)\s*=\s*"(?P<value>.*)(?<!\\\\)"\s*$')
		reOptionList	= re.compile('^(?P<key>[A-Z0-9_]*)\s*=\s*"(?P<item>.*)\s*$')
		reLastListItem	= re.compile('^\s+(?P<item>.*)(?<!\\\\)"\s*$')
		reListItem		= re.compile('^\s+(?P<item>.*)\s*$')

		reShellStart	= re.compile('^(?P<key>[A-Z_]*)\s*\{\s*$')
		reShellEnd		= re.compile('^\}\s*$')

		reComment		= re.compile('^\s*#.*$')
		reEmptyLine		= re.compile('^\s*$')

		reNoneType		= re.compile('^\s*$')
		reIntType		= re.compile('^[0-9]+$')
		reBooleanType	= re.compile('^yes$|^no$')
		reStatusType	= re.compile('^broken$|^untested$|^unstable$|^stable$')

		self.options = {}

		self.filename = filename

		try:
			self.file = open(self.filename, 'rb')
		except:
			sys.exit("Error: Can't find config file: " + self.filename)

		self.lineCount = 0
		self.nextLine()
		# TODO: store all options in a list?
		while self.line != "":
			# empty line or comment
			if reEmptyLine.match(self.line) or reComment.match(self.line):
				pass
			# value option (single line) (check BEFORE list option)
			elif reOptionValue.match(self.line):
				#print "[OV] " + self.line.strip('\n')
				m = reOptionValue.match(self.line)
				key = m.group("key")
				value = m.group("value")
				if reNoneType.match(value):			# NoneType
					self.options[key] = None
				elif reIntType.match(value):		# IntType
					self.options[key] = int(value)
				elif reBooleanType.match(value):	# BooleanType
					if value == "yes":
						self.options[key] = True
					else:
						self.options[key] = False
				elif reStatusType.match(value):		# StatusType
					self.options[key] = status(value)
				else:								# StringType
					self.options[key] = value
			# list option (multiline)
			elif reOptionList.match(self.line):
				#print "[OL] " + self.line.strip('\n')
				m = reOptionList.match(self.line)
				key = m.group("key")
				self.options[key] = [m.group("item")]
				self.nextLine()
				while self.line != "":
					# empty line or comment
					if reEmptyLine.match(self.line) or reComment.match(self.line):
						pass
					# last list item (check BEFORE list item)
					elif reLastListItem.match(self.line):
						#print "[LL] " + self.line.strip('\n')
						m = reLastListItem.match(self.line)
						self.options[key].append(m.group("item"))
						break
					# list item
					elif reListItem.match(self.line):
						#print "[LI] " + self.line.strip('\n')
						m = reListItem.match(self.line)
						self.options[key].append(m.group("item"))
					# unrecognized syntax
					else:
						self.illegalSyntax()
					self.nextLine()
			# shell commands (multiline)
			elif reShellStart.match(self.line):
				#print "[SS] " + self.line.strip('\n')
				m = reShellStart.match(self.line)
				key = m.group("key")
				self.options[key] = shell()
				self.nextLine()
				while self.line != "":
					# empty line or comment
					if reEmptyLine.match(self.line) or reComment.match(self.line):
						pass
					# last list item (check BEFORE list item)
					elif reShellEnd.match(self.line):
						#print "[SE] " + self.line.strip('\n')
						break
					# list item
					elif reListItem.match(self.line):
						#print "[SI] " + self.line.strip('\n')
						m = reListItem.match(self.line)
						self.options[key].append(m.group("item"))
					# unrecognized syntax
					else:
						self.illegalSyntax()
					self.nextLine()
			# unrecognized syntax
			else:
				self.illegalSyntax()
			self.nextLine()
		self.file.close()
		#for key in self.options:
		#	print key + " = " + str(self.options[key])

	def nextLine(self):
		self.line = self.file.readline()
		self.lineCount = self.lineCount + 1

	def illegalSyntax(self):
		print "Error: Illegal syntax in " + self.filename + " at line " + str(self.lineCount) + ":"
		print "  " + self.line
		sys.exit(1)

	def getKeys(self):
		return self.options

	def valueOf(self, key):
		try:
			value = self.options[key]
			return value
		except KeyError:	# an unspecified option is the same as an empty one
			return ""

# -- Command line argument parsing -------------------------------------------

parser = OptionParser(usage="usage: %prog [options] portname[-portversion]",
						version="%prog " + info['version'])

parser.add_option("-l", "--list",
	action="store_true", dest="list", default=False,
	help="list available ports")

parser.add_option("-a", "--about",
	action="store_true", dest="about", default=False,
	help="show description of the specified port")

parser.add_option("-s", "--search",
	action="store_true", dest="search", default=False,
	help="search for a port (regex)")

parser.add_option("-p", "--nopatch",
	action="store_false", dest="patch", default=True,
	help="don't patch the sources, just download and unpack")

parser.add_option("-b", "--nobuild",
	action="store_false", dest="build", default=True,
	help="don't build the port, just download, unpack and patch")

parser.add_option("-i", "--install",
	action="store_true", dest="install", default=False,
	help="also install the port (the default is to only build)")
	
parser.add_option("-d", "--distro",
	action="store_true", dest="distro", default=False,
	help="make distribution package of the specified port (include download, unpack, patch, build)")

parser.add_option("-c", "--clean",
	action="store_true", dest="clean", default=False,
	help="clean the working directory of the specified port")

parser.add_option("-g", "--get",
	action="store_true", dest="get", default=False,
	help="get/update the ports tree")

parser.add_option("-f", "--force",
	action="store_true", dest="force", default=False,
	help="force to perform the steps (unpack, patch, build)")

parser.add_option("-z", "--archive",
	action="store_true", dest="archive", default=False,
	help="Create a patched source archive as <package>_haiku.tar.xz")

(options, args) = parser.parse_args()

haikuporter = HaikuPorter(options, args)

