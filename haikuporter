#!/boot/common/bin/python
# -*- coding: utf8 -*-
# copyright 2007-2009 Brecht Machiels
# copyright 2009 HaikuBot (aka RISC)
# copyright 2009 Scott McCreary
# copyright 2009 Alexander Deynichenko

info = {}
info['version'] = "0.43"

# -- Modules ------------------------------------------------------------------

import sys
import os
import re
import urllib
import urllib2
import time
import locale
import tarfile
import zipfile
import types
from optparse import OptionParser

# -- HaikuPorts options -------------------------------------------------------

# location of haikuports.conf
haikuPortsConf = '/boot/common/etc/haikuports.conf'

# create new type 'ShellType' for identifying lists of shell commands
class shell(list):
	pass
ShellType = shell

# create new type 'StatusType' for identifying the port's status on a platform
#  the possible states are defined in the 'Config' class (reStatusType)
class status(str):
	pass
StatusType = status

# allowed types of the /etc/haikuports.conf values
confTypes = {}
confTypes['PACKAGES_PATH'] = [types.StringType]

# allowed types of the BepFile values
bepTypes = {}
bepTypes['DESCRIPTION']	= [types.StringType, types.ListType]
bepTypes['HOMEPAGE']	= [types.StringType]
bepTypes['SRC_URI']		= [types.StringType, types.ListType]
bepTypes['REVISION']	= [types.IntType]
bepTypes['STATUS_HAIKU']= [StatusType]
bepTypes['DEPEND']		= [types.StringType, types.ListType, types.NoneType]
bepTypes['BUILD']		= [ShellType]
bepTypes['INSTALL']		= [ShellType]

							# is field	 #	default
bepDefaults = {}			# required?	 #	value
bepDefaults['DESCRIPTION']	= [True,		None		]
bepDefaults['HOMEPAGE']		= [True,		None		]
bepDefaults['SRC_URI']		= [True,		None		]
bepDefaults['REVISION']		= [True,		None		]
bepDefaults['WORKING']		= [False,		True		]
bepDefaults['STATUS_HAIKU']	= [False,		'untested'	]
bepDefaults['DEPEND']		= [False,		None		]
bepDefaults['BUILD']		= [False,		shell()		]
bepDefaults['INSTALL']		= [False,		shell()		]

# names of directories
paths = {}
paths['work']		= "work"
paths['patches']	= "patches"
paths['download']	= "download"
paths['distro']		= "distro"

# -- downloadProgressIndicator properties ------------------------------------

totalSteps = 35
singleStep = 100.0/totalSteps

# -- capture output of shell command -----------------------------------------
#  from http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52296

def getCommandOutput(command):
	child = os.popen(command)
	data = child.read()
	err = child.close()
	if err:
		raise RuntimeError, '%s failed w/ exit code %d' % (command, err)
	return data

# -- Set up locale for thousands seperators ----------------------------------
def _temp(lc=locale.localeconv()):
        lc.update({'thousands_sep':',','grouping':[3,3,0]})
        return lc

locale.localeconv=_temp

# -- Main Program ------------------------------------------------------------

class HaikuPorter:
	def __init__(self, options, args):
		# read global settings
		mainConfig = Config(haikuPortsConf)
		self.confKeys = mainConfig.getKeys()

		for key in self.confKeys:
			try:
				if type(self.confKeys[key]) not in confTypes[key]:
					print "Invalid value type for " + key + ". Expecting " + str(confTypes[key])
					sys.exit()
			except KeyError, e:
				print "Unknown key label '" + key + "' in " + haikuPortsConf + ". Ignoring."

		self.packagesPath = self.confKeys['PACKAGES_PATH']
		if self.packagesPath[-1] == '/':
			# strip trailing '/'
			self.packagesPath = self.packagesPath[:-1]
		
		# if requested, list all ports in the HaikuPorts tree
		if options.list:
			self.listPorts()
			sys.exit()
		
		# if requested, search for a port
		if options.search:
			if len(args) == 0:
				print "You need to specifiy a search string"
				print "Invoke '" + sys.argv[0] + " -h' for usage information."
				sys.exit()

			self.searchPorts(args[0])
			sys.exit()

		# if requested, get ports tree
		if options.get:
			self.getTree()
			sys.exit()

		# if requested, update ports tree
		if options.update:
			self.updateTree()
			sys.exit()

		# if there is no argument given, exit
		if len(args) == 0:
			print "You need to specifiy at least a port name."
			print "Invoke '" + sys.argv[0] + " -h' for usage information."
			sys.exit()
		else:
			port = args[0]

		# split the argument into a port name and a version
		reWithVersion = re.compile('^(?P<name>[a-z0-9\-_]*)-(?P<version>([\d]+[a-z\\.])*[\d]*)?$')
		reWithoutVersion = re.compile('^(?P<name>[a-z0-9\-_]*)$')
		if reWithVersion.match(port):		# with version
			m = reWithVersion.match(port)
			self.portName = m.group("name")
			self.portVersion = m.group("version")
		elif reWithoutVersion.match(port):	# without version
			m = reWithoutVersion.match(port)
			self.portName = m.group("name")
			self.portVersion = None
		else:								# invalid argument
			print "Invalid port name: " + port
			sys.exit()						

		# find the port in the HaikuPorts tree
		self.portCategory = self.getCategory(self.portName)
		if self.portCategory == None:
			print "Port " + self.portName + " not found. Exiting."
			sys.exit()

		# create full paths for the directories
		self.portDir	= self.packagesPath + '/' + self.portCategory + '/' + self.portName
		self.downloadDir= self.portDir + '/' + paths['download']
		self.workDir	= self.portDir + '/' + paths['work']
		self.patchesDir	= self.portDir + '/' + paths['patches']
		self.distroDir	= self.portDir + '/' + paths['distro']

		# if the port version was not specified, list available versions
		if self.portVersion == None:
			versions = []
			reBepFile = re.compile('^(?P<name>[a-z0-9\-_]*)-(?P<version>([\d]+[a-z\\.])*[\d]*)?\.bep$')
			os.chdir(self.portDir)
			dirList = os.listdir(".")
			for item in dirList:
				m = reBepFile.match(item)
				if m:
					versions.append([m.group("version"), item])
			if len(versions) > 1:
				print "Following versions of %s are available:" % (self.portName)
				for version in versions:
					print "  " + version[0]
				print "Run haikuporter again, specifiying a port version"
				sys.exit()
			elif len(versions) == 1:
				self.portVersion = versions[0][0]
			else:
				print ".bep files for %s not found. Exiting." % (self.portName)
				sys.exit()

		# show port description, if requested
		if options.about:
			self.about()
			sys.exit()
		
		# read data from the bep file
		self.parseBepFile()

		# warn when the port is not stable on this platform
		self.platform = self.detectOS()
		if self.platform == None:
			print "Unknown OS platform!"
		else:
			if self.bepKeys['STATUS_' + self.platform] != "stable":
				print "Warning: this port is " + self.bepKeys['STATUS_' + self.platform] + " on this platform.",
				answer = raw_input("Continue (y/n + enter)? ")
				if answer == '':
					sys.exit()
				if answer[0].lower() == 'y':
					print "ok"
					pass
				else:
					sys.exit()

		# clean the work directory, if requested
		if options.clean:
			self.clean()
		
		# don't build when not patching
		if not options.patch:
			options.build = False

		self.checkDeps()	# check dependencies
		self.fetch()		# fetch sources
		self.unpack()		# unpack source archive
		if options.patch:
			self.patch()	# apply patches
		if options.build:
			self.build()	# build
		if options.install:
			self.install()	# install
		if options.distro:
			self.distro()	# distro

	def about(self):
		"""Show port description"""
		os.chdir(self.portDir)
				
		bepFilename = self.portName + '-' + self.portVersion + ".bep"
		
		reOptionValue	= re.compile('^(?P<key>[A-Z0-9_]*)\s*=\s*"(?P<value>.*)(?<!\\\\)"\s*$')
		reComment		= re.compile('^\s*#.*$')
		reEmptyLine		= re.compile('^\s*$')
				
		if not os.path.exists(bepFilename):
			print self.portName + " version " + self.portVersion + " not found"
			sys.exit()
					
				
		fp = open(bepFilename)
		lineCount = 0
		
		line = fp.readline()
		lineCount += 1
		
		print '*'*80
		
		while line != "":
			# empty line or comment
			if reEmptyLine.match(line) or reComment.match(line):
				pass
			# value option (single line) (check BEFORE list option)
			elif reOptionValue.match(line):
				m = reOptionValue.match(line)
				key = m.group("key")
				value = m.group("value")
				
				if 'DESCRIPTION' in key:
					print key.capitalize()+":",value
				elif 'HOMEPAGE' in key:
					print key.capitalize()+":",value
				
			line = fp.readline()
			lineCount += 1
			
		print '*'*80
		
		fp.close()
	
	def getTree(self):
		""" Get port tree via svn"""
		cd = 'cd $(finddir B_COMMON_DEVELOP_DIRECTORY);'
		svn = 'svn co http://ports.haiku-files.org/svn/haikuports/trunk haikuports'
		os.system(cd + svn)

	def updateTree(self):
		""" Update port tree via svn"""
		cd = 'cd $(finddir B_COMMON_DEVELOP_DIRECTORY)/haikuports;'
		svn = 'svn up'
		os.system(cd + svn)

	def parseBepFile(self):
		"""Parse the BepFile of the specified port"""
		os.chdir(self.portDir)
		bepFilename = self.portName + "-" + self.portVersion + ".bep"
		if not os.path.exists(bepFilename):
			print self.portName + " version " + self.portVersion + " not found"
			sys.exit()
		bepConfig = Config(bepFilename)
		self.bepKeys = bepConfig.getKeys()

		# check whether all required fields are present
		for key in bepDefaults:
			if key not in self.bepKeys and bepDefaults[key][0]:
					print "Required field '" + key + "' not present in " + bepFilename
					sys.exit()

		# check validity of BepFile values
		for key in self.bepKeys:
			try:
				if type(self.bepKeys[key]) not in bepTypes[key]:
					print "Invalid value type for " + key + ". Expecting " + str(bepTypes[key])
					sys.exit()
			except KeyError, e:
				print "Unknown key label '" + key + "'. Ignoring."

		# set default values when not provided
		for key in bepDefaults:
			if key not in self.bepKeys:
				self.bepKeys[key] = bepDefaults[key][1]
		
		# convert each None/string value into a list (with respectively 0 or 1 element)
		#	(simplifies implementation ahead)
		for key in bepTypes:
			if types.ListType in bepTypes[key]:
				if self.bepKeys[key] == None:
					self.bepKeys[key] = []
				elif type(self.bepKeys[key]) == types.StringType:
					self.bepKeys[key] = [self.bepKeys[key]]
				else:
					pass

		#for key in self.bepKeys:
		#	print key + " = " + str(self.bepKeys[key])


	def detectOS(self):
		"""Detect the platform we're running on"""
		name = getCommandOutput('uname -s')[0:-1]
		if name == "Haiku":
			return name.upper()
		# Support for R5, R5bone, dano, and Zeta has been dropped.
		else:
			return None

	def listPorts(self):
		"""List all of the ports in the HaikuPorts tree"""
		hierarchy = []
		os.chdir(self.packagesPath)
		dirList = os.listdir(self.packagesPath)
		for category in dirList:
			if os.path.isdir(category) and (category[0] != '.'):
				subdirList = os.listdir(category)
				# remove items starting with '.'
				subdirList.sort()
				for portName in subdirList:
					if portName[0][0] != '.':
						print category + "/" + portName

	def searchPorts(self, regExp):
		"""Search for a port in the HaikuPorts tree"""
		reSearch = re.compile(regExp)
		hierarchy = []
		os.chdir(self.packagesPath)
		dirList = os.listdir(self.packagesPath)
		for category in dirList:
			if os.path.isdir(category) and (category[0] != '.'):
				subdirList = os.listdir(category)
				# remove items starting with '.'
				subdirList.sort()
				for portName in subdirList:
					if portName[0][0] != '.' and reSearch.search(portName):
						print category + "/" + portName

	def getCategory(self, portName):
		"""Find location of the specified port in the HaikuPorts tree"""
		hierarchy = []
		os.chdir(self.packagesPath)
		dirList = os.listdir(self.packagesPath)
		for item in dirList:
			if os.path.isdir(item) and (item[0] != '.'):
				subdirList = os.listdir(item)
				# remove items starting with '.'
				subdirList.sort()
				while subdirList[0][0] == '.':
					del subdirList[0]
				# locate port
				try:
					if subdirList.index(portName) >= 0:
						# port was found in the category specified by 'item'
						return item
				except ValueError:
					pass
				hierarchy.append([item, subdirList])
		return None

	def clean(self):
		"""Clean the working directory"""
		os.chdir(self.portDir)
		if os.path.exists(paths['work']):
			print "Cleaning work directory..."
			os.system("rm -rf " + paths['work']) # TODO: replace with Python function

	def checkDeps(self):
		"""Print the list of ports this one depends on"""
		if self.bepKeys['DEPEND'] == []:
			print "No dependencies"
			return
		print "This port depends on the following ports:"
		for item in self.bepKeys['DEPEND']:
			print "  " + item
		print "Please verify that you have these installed.",
		answer = raw_input("Continue (y/n + enter)? ")
		if answer == '':
			sys.exit()
		if answer[0].lower() == 'y':
			print "ok"
			pass
		else:
			sys.exit()
		
	def fetch(self):
		"""Fetch the source archive"""
		# create download dir
		if not os.path.exists(self.downloadDir):
			os.mkdir(self.downloadDir)
		# fetch source archive
		self.lastBytes = 0
		self.progressSpeed = 0
		self.timeLeft = None
		self.lastTime = time.time()
		os.chdir(self.downloadDir)
		for src_uri in self.bepKeys['SRC_URI']:
			fp = self.downloadDir+'/'+src_uri[src_uri.rindex('/') + 1:]
			if os.path.isfile(fp):
				print 'Seems file already exist, checkout: ' + fp + '.\nSkip fetching file...'
				self.src_local = src_uri[src_uri.rindex('/') + 1:]
				return
			else:
				print "Fetching " + src_uri
				try:
					file_uri = urllib2.urlopen(src_uri)
					headers = file_uri.info()
					remote_size = long(headers.getheader("Content-Length"))
					src_uri = file_uri.geturl()
					self.src_local = src_uri[src_uri.rindex('/') + 1:]
					if os.path.exists(self.src_local):
						local_size = os.stat(self.src_local).st_size
					else:
						local_size = 0
					# check if file was already downloaded
					if local_size == remote_size:
						print '  file was already downloaded... continuing'
					else:
						os.system('wget ' + src_uri)
						# urllib.urlretrieve(src_uri, self.src_local, self.downloadProgressIndicator)
						print ''
					# succesfully downloaded source archive
					return
				except:
					raise
					print "  error... trying next location"
					continue
		# failed to fetch source
		print "Failed to fetch source package from all locations"
		sys.exit()

	def downloadProgressIndicator(self, *a):
		"""Show a progress bar, download speed and ETA"""
		current = float(a[0])
		block = float(a[1])
		total = float(a[2])
		currentBytes = int(current * block)
		if currentBytes > total:
			currentBytes = total
		percentComplete = 100 * currentBytes / (total)
		currentStep = int(percentComplete / singleStep)
		progressBar = '['
		for step in range(totalSteps):
			if step < currentStep:
				progressBar = progressBar + '='
			elif step == currentStep:
				progressBar = progressBar + '>'
			else:
				progressBar = progressBar + ' '
		progressBar = progressBar + ']'
		currentTime = time.time()
		deltaTime = currentTime - self.lastTime
		if deltaTime > 0.5:
			deltaBytes = currentBytes - self.lastBytes
			self.progressSpeed = round(deltaBytes / deltaTime / 1000 , 2)
			self.lastTime = currentTime
			self.lastBytes = currentBytes
			bytesLeft = total - currentBytes
			if self.progressSpeed != 0:
				secondsLeft = bytesLeft / self.progressSpeed / 1000
				if secondsLeft > 3600:
					self.timeLeft = time.strftime('%H:%M:%S', time.gmtime(secondsLeft))
				else:
					self.timeLeft = time.strftime('%M:%S', time.gmtime(secondsLeft))
		
		progressInfo = str(int(percentComplete)).rjust(3)  + '% ' \
						+ progressBar \
						+ ' ' + locale.format('%d', currentBytes, grouping=True).ljust(8) \
						+ ' ' + str(self.progressSpeed).rjust(8) + 'K/s'
		if self.timeLeft != None:
			progressInfo = progressInfo \
						+ '    ' + 'ETA ' + str(self.timeLeft)
		sys.stdout.write('\r' + progressInfo)
		sys.stdout.flush()

	def unpack(self):
		"""Unpack the source archive (into the work directory)"""
		# create work dir
		if not os.path.exists(self.workDir):
			os.mkdir(self.workDir)
		# unpack source archive
		os.chdir(self.workDir)
		print "Unpacking " + self.src_local
		archiveFullPath = self.downloadDir + "/" + self.src_local
		if tarfile.is_tarfile(archiveFullPath): 
			tf = tarfile.open(self.downloadDir + "/" + self.src_local, 'r')
			tf.extractall()
			tf.close()
		elif zipfile.is_zipfile(archiveFullPath):
			zf = zipfile.ZipFile(self.downloadDir + "/" + self.src_local, 'r')
			zf.extractall()
			zf.close()
		else:
			print "Unrecognised archive type"
			sys.exit()
			
	def patch(self):
		"""Apply the Haiku patches to the source directory"""
		os.chdir(self.workDir)
		patchFilePath = self.patchesDir + '/' + self.portName + '-' + self.portVersion + '.patch'
		if os.path.exists(patchFilePath):
			os.system("patch -p0 -i " + patchFilePath)
			# TODO: check return code
		else:
			print "No patching required"

	def build(self):
		"""Build the sources"""
		os.chdir(self.workDir)
		# TODO: if self.bepKeys['BUILD'] = empty, warn user
		buildCommands = ''
		for command in self.bepKeys['BUILD']:
			if buildCommands != '':
				buildCommands = buildCommands + " && "
			buildCommands = buildCommands + command
		os.system(buildCommands)
			
	def install(self):
		"""Install the binaries onto the system"""
		os.chdir(self.workDir)
		# TODO: if self.bepKeys['INSTALL'] = empty, warn user
		installCommands = ''
		for command in self.bepKeys['INSTALL']:
			if installCommands != '':
				installCommands = installCommands + " && "
			installCommands = installCommands + command
		os.system(installCommands)
		
	def distro(self):
		# create distro dir
		if not os.path.exists(self.distroDir):
			os.mkdir(self.distroDir)
			
		os.chdir(self.workDir)
		# TODO: if self.bepKeys['INSTALL'] = empty, warn user
		installCommands = ''
		for command in self.bepKeys['INSTALL']:
			if 'make install' in command:
				command = 'make install DESTDIR='+ self.distroDir
			if installCommands != '':
				installCommands = installCommands + " && "
			installCommands = installCommands + command
		os.system(installCommands)
		
		# get OptionalPackageDescription
		os.chdir(self.portDir)
		
		opd = False
		for f in os.listdir(self.portDir):
			if 'OptionalPackageDescription' in f:
				os.system('cp ' + self.portDir + '/' + f + ' ' + self.distroDir + '/.OptionalPackageDescription')				
				opd = True

		for f in os.listdir(self.portDir):
			if 'licenses' in f:
				os.system ('mkdir -p ' + self.portDir + '/common/data/licenses')
				os.system ('cp ' + self.portDir + '/' + f + ' ' + self.distroDir + '/' + f)
		
		# go to distro dir for making zip package
		os.chdir(self.distroDir)
		
		package = self.portName + '-' + self.portVersion
		
		gcc = getCommandOutput('setgcc')
		gcc = gcc.split(': ')[1].split('/')
		arch = '-' + gcc[0]
		gcc = '-' + gcc[1][:-1]

		date = time.localtime()
		date = '-' + str(date[0]) + '-' + str(date[1]) + '-' + str(date[2])
		
		os.system('mv ./boot/apps ./apps')
		os.system('mv ./boot/common ./common')

		if opd:
			os.system('zip -ry9 ' + package + arch + gcc + date + '.zip ./common ./apps .OptionalPackageDescription')
			os.system('rm -rf ./common ./apps .OptionalPackageDescription')
		else:
			os.system('zip -ry9 ' + package + arch + gcc + date + '.zip ./common ./apps')
			os.system('rm -rf ./common ./apps')
		

# -- /etc/haikuports.conf and *.bep parser -----------------------------------

class Config:
	def __init__(self, filename):
		# regular expressions for parsing the config file
		reOptionValue	= re.compile('^(?P<key>[A-Z0-9_]*)\s*=\s*"(?P<value>.*)(?<!\\\\)"\s*$')
		reOptionList	= re.compile('^(?P<key>[A-Z0-9_]*)\s*=\s*"(?P<item>.*)\s*$')
		reLastListItem	= re.compile('^\s+(?P<item>.*)(?<!\\\\)"\s*$')
		reListItem		= re.compile('^\s+(?P<item>.*)\s*$')

		reShellStart	= re.compile('^(?P<key>[A-Z_]*)\s*\{\s*$')
		reShellEnd		= re.compile('^\}\s*$')

		reComment		= re.compile('^\s*#.*$')
		reEmptyLine		= re.compile('^\s*$')
		
		reNoneType		= re.compile('^\s*$')
		reIntType		= re.compile('^[0-9]+$')
		reBooleanType	= re.compile('^yes$|^no$')
		reStatusType	= re.compile('^broken$|^untested$|^unstable$|^stable$')
		
		self.options = {}

		self.filename = filename
		
		try:
			self.file = open(self.filename, 'rb')
		except:
			print "Can't find config file: " + self.filename
			sys.exit()
			
		self.lineCount = 0
		self.nextLine()
		# TODO: store all options in a list?
		while self.line != "":
			# empty line or comment
			if reEmptyLine.match(self.line) or reComment.match(self.line):
				pass
			# value option (single line) (check BEFORE list option)
			elif reOptionValue.match(self.line):
				#print "[OV] " + self.line.strip('\n')
				m = reOptionValue.match(self.line)
				key = m.group("key")
				value = m.group("value")
				if reNoneType.match(value):			# NoneType
					self.options[key] = None
				elif reIntType.match(value):		# IntType
					self.options[key] = int(value)
				elif reBooleanType.match(value):	# BooleanType
					if value == "yes":
						self.options[key] = True
					else:
						self.options[key] = False
				elif reStatusType.match(value):		# StatusType
					self.options[key] = status(value)
				else:								# StringType
					self.options[key] = value
			# list option (multiline)
			elif reOptionList.match(self.line):
				#print "[OL] " + self.line.strip('\n')
				m = reOptionList.match(self.line)
				key = m.group("key")
				self.options[key] = [m.group("item")]
				self.nextLine()
				while self.line != "":
					# empty line or comment
					if reEmptyLine.match(self.line) or reComment.match(self.line):
						pass
					# last list item (check BEFORE list item)
					elif reLastListItem.match(self.line):
						#print "[LL] " + self.line.strip('\n')
						m = reLastListItem.match(self.line)
						self.options[key].append(m.group("item"))
						break
					# list item
					elif reListItem.match(self.line):
						#print "[LI] " + self.line.strip('\n')
						m = reListItem.match(self.line)
						self.options[key].append(m.group("item"))
					# unrecognized syntax
					else:
						self.illegalSyntax()
					self.nextLine()
			# shell commands (multiline)
			elif reShellStart.match(self.line):
				#print "[SS] " + self.line.strip('\n')
				m = reShellStart.match(self.line)
				key = m.group("key")
				self.options[key] = shell()
				self.nextLine()
				while self.line != "":
					# empty line or comment
					if reEmptyLine.match(self.line) or reComment.match(self.line):
						pass
					# last list item (check BEFORE list item)
					elif reShellEnd.match(self.line):
						#print "[SE] " + self.line.strip('\n')
						break
					# list item
					elif reListItem.match(self.line):
						#print "[SI] " + self.line.strip('\n')
						m = reListItem.match(self.line)
						self.options[key].append(m.group("item"))
					# unrecognized syntax
					else:
						self.illegalSyntax()
					self.nextLine()
			# unrecognized syntax
			else:
				self.illegalSyntax()
			self.nextLine()
		self.file.close()
		#for key in self.options:
		#	print key + " = " + str(self.options[key])

	def nextLine(self):
		self.line = self.file.readline()
		self.lineCount = self.lineCount + 1
		
	def illegalSyntax(self):
		print "Illegal syntax in " + self.filename + " at line " + str(self.lineCount) + ":"
		print "  " + self.line
		sys.exit()
		
	def getKeys(self):
		return self.options
	
	def valueOf(self, key):
		try:
			value = self.options[key]
			return value
		except KeyError:	# an unspecified option is the same as an empty one
			return ""

# -- Command line argument parsing -------------------------------------------

parser = OptionParser(usage="usage: %prog [options] portname[-portversion]",
						version="%prog " + info['version'])

parser.add_option("-l", "--list",
	action="store_true", dest="list", default=False,
	help="list available ports")

parser.add_option("-a", "--about",
	action="store_true", dest="about", default=False,
	help="show description of the specified port")
		
parser.add_option("-s", "--search",
	action="store_true", dest="search", default=False,
	help="search for a port (regex)")

parser.add_option("-p", "--nopatch",
	action="store_false", dest="patch", default=True,
	help="don't patch the sources, just download and unpack")

parser.add_option("-b", "--nobuild",
	action="store_false", dest="build", default=True,
	help="don't build the port, just download, unpack and patch")

parser.add_option("-i", "--install",
	action="store_true", dest="install", default=False,
	help="also install the port (the default is to only build)")
	
parser.add_option("-d", "--distro",
	action="store_true", dest="distro", default=False,
	help="make distribution package of the specified port (include download, unpack, patch, build)")

parser.add_option("-c", "--clean",
	action="store_true", dest="clean", default=False,
	help="clean the working directory of the specified port")
	
parser.add_option("-g", "--get",
	action="store_true", dest="get", default=False,
	help="get ports tree")

parser.add_option("-u", "--update",
	action="store_true", dest="update", default=False,
	help="update ports tree (you should get it before)")

(options, args) = parser.parse_args()

haikuporter = HaikuPorter(options, args)

